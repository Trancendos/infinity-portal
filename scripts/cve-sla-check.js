/**
 * cve-sla-check.js
 * CVE SLA Enforcement Engine
 * ISO 27001: A.12.6.1 - Technical Vulnerability Management
 * ISO 27001: A.16.1.4 - Assessment and Decision on Information Security Events
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

const SLA_CONFIG = {
  critical: { days: 7,   label: 'cve-critical', color: 'b60205', cvssMin: 9.0 },
  high:     { days: 14,  label: 'cve-high',     color: 'd93f0b', cvssMin: 7.0 },
  medium:   { days: 30,  label: 'cve-medium',   color: 'fbca04', cvssMin: 4.0 },
  low:      { days: 90,  label: 'cve-low',      color: '0e8a16', cvssMin: 0.1 },
  info:     { days: 180, label: 'cve-info',      color: 'c5def5', cvssMin: 0.0 },
};

const CONFIG = {
  offlineMode: process.env.OFFLINE_MODE === 'true' || process.argv.includes('--offline'),
  cveDbPath: process.env.CVE_DB_PATH || './cve-database.json',
  githubToken: process.env.GH_TOKEN || process.env.GITHUB_TOKEN,
  githubRepo: process.env.GITHUB_REPOSITORY || 'Trancendos/infinity-portal',
  scanPaths: ['.', './backend', './apps/shell', './packages'],
  severityFilter: null,
};

const sevIdx = process.argv.indexOf('--severity');
if (sevIdx !== -1 && process.argv[sevIdx + 1]) {
  CONFIG.severityFilter = process.argv[sevIdx + 1].split(',').map(s => s.trim().toLowerCase());
}

function parseNPMDeps(pkgPath) {
  const deps = [];
  try {
    const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf-8'));
    for (const [name, ver] of Object.entries({ ...pkg.dependencies, ...pkg.devDependencies })) {
      deps.push({ name, version: ver.replace(/[\^~>=<]/g, '').split(' ')[0], ecosystem: 'npm', source: pkgPath });
    }
  } catch (e) { console.warn(`Failed to parse ${pkgPath}: ${e.message}`); }
  return deps;
}

function parsePythonDeps(reqPath) {
  const deps = [];
  try {
    for (const line of fs.readFileSync(reqPath, 'utf-8').split('\n')) {
      const t = line.trim();
      if (!t || t.startsWith('#') || t.startsWith('-')) continue;
      const m = t.match(/^([a-zA-Z0-9_.-]+)\s*([=<>!~]+\s*[\d.]+)?/);
      if (m) deps.push({ name: m[1], version: m[2] ? m[2].replace(/[=<>!~\s]/g, '') : 'unknown', ecosystem: 'pypi', source: reqPath });
    }
  } catch (e) { console.warn(`Failed to parse ${reqPath}: ${e.message}`); }
  return deps;
}

function parseCargoDeps(cargoPath) {
  const deps = [];
  try {
    const content = fs.readFileSync(cargoPath, 'utf-8');
    const section = content.match(/\[dependencies\]([\s\S]*?)(\[|$)/);
    if (section) {
      for (const line of section[1].split('\n')) {
        const m = line.match(/^(\w[\w-]*)\s*=\s*"([^"]+)"/);
        if (m) deps.push({ name: m[1], version: m[2], ecosystem: 'crates', source: cargoPath });
      }
    }
  } catch (e) { console.warn(`Failed to parse ${cargoPath}: ${e.message}`); }
  return deps;
}

function collectDeps() {
  const deps = [];
  for (const scanPath of CONFIG.scanPaths) {
    const pkgJson = path.join(scanPath, 'package.json');
    const reqTxt = path.join(scanPath, 'requirements.txt');
    const cargoToml = path.join(scanPath, 'Cargo.toml');
    if (fs.existsSync(pkgJson)) deps.push(...parseNPMDeps(pkgJson));
    if (fs.existsSync(reqTxt)) deps.push(...parsePythonDeps(reqTxt));
    if (fs.existsSync(cargoToml)) deps.push(...parseCargoDeps(cargoToml));
  }
  return deps;
}

function classifySeverity(cvss) {
  if (cvss >= 9.0) return 'critical';
  if (cvss >= 7.0) return 'high';
  if (cvss >= 4.0) return 'medium';
  if (cvss >= 0.1) return 'low';
  return 'info';
}

async function checkOSVApi(dep) {
  if (CONFIG.offlineMode) return [];
  try {
    const resp = await fetch('https://api.osv.dev/v1/query', {
      method: 'POST', headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ package: { name: dep.name, ecosystem: dep.ecosystem === 'pypi' ? 'PyPI' : dep.ecosystem === 'npm' ? 'npm' : 'crates.io' }, version: dep.version }),
    });
    if (!resp.ok) return [];
    const data = await resp.json();
    return (data.vulns || []).map(v => ({
      id: v.id, summary: (v.summary || '').substring(0, 200),
      severity: classifySeverity(v.database_specific?.cvss_score || v.severity?.[0]?.score || 5.0),
      cvss: v.database_specific?.cvss_score || v.severity?.[0]?.score || 5.0,
      published: v.published, dep: dep.name, version: dep.version, ecosystem: dep.ecosystem,
    }));
  } catch (e) { return []; }
}

async function createGitHubIssue(vuln) {
  if (!CONFIG.githubToken) return;
  const sla = SLA_CONFIG[vuln.severity];
  const [owner, repo] = CONFIG.githubRepo.split('/');
  try {
    const resp = await fetch(`https://api.github.com/repos/${owner}/${repo}/issues`, {
      method: 'POST',
      headers: { Authorization: `Bearer ${CONFIG.githubToken}`, 'Content-Type': 'application/json', Accept: 'application/vnd.github.v3+json' },
      body: JSON.stringify({
        title: `[${vuln.severity.toUpperCase()}] ${vuln.id}: ${vuln.dep}@${vuln.version}`,
        body: `## CVE SLA Alert\n\n**CVE:** ${vuln.id}\n**Package:** ${vuln.dep}@${vuln.version}\n**Ecosystem:** ${vuln.ecosystem}\n**Severity:** ${vuln.severity} (CVSS: ${vuln.cvss})\n**SLA:** ${sla.days} days\n**Summary:** ${vuln.summary}\n\n*ISO 27001: A.12.6.1*`,
        labels: ['security', sla.label, 'auto-generated'],
      }),
    });
    if (resp.ok) console.log(`Created issue for ${vuln.id}`);
  } catch (e) { console.warn(`Failed to create issue: ${e.message}`); }
}

async function main() {
  console.log('Starting CVE SLA Enforcement Check...');
  const deps = collectDeps();
  console.log(`Found ${deps.length} dependencies across ${CONFIG.scanPaths.length} paths`);
  const vulns = [];
  for (const dep of deps) {
    const found = await checkOSVApi(dep);
    vulns.push(...found);
  }
  if (CONFIG.severityFilter) {
    vulns.filter(v => CONFIG.severityFilter.includes(v.severity));
  }
  const summary = { total: vulns.length, critical: 0, high: 0, medium: 0, low: 0, info: 0, breached: 0, urgent: 0 };
  const now = Date.now();
  for (const v of vulns) {
    summary[v.severity]++;
    if (v.published) {
      const age = Math.floor((now - new Date(v.published).getTime()) / 86400000);
      const sla = SLA_CONFIG[v.severity];
      if (age > sla.days) { summary.breached++; v.breached = true; v.overdueDays = age - sla.days; }
      if (age > sla.days * 0.8) summary.urgent++;
    }
  }
  const report = { ...summary, vulnerabilities: vulns, timestamp: new Date().toISOString(), complianceStatus: summary.breached === 0 ? 'COMPLIANT' : 'NON_COMPLIANT' };
  fs.writeFileSync('cve-sla-report.json', JSON.stringify(report, null, 2));
  console.log(`Found ${vulns.length} vulnerabilities: ${summary.critical} critical, ${summary.high} high, ${summary.medium} medium`);
  console.log(`SLA breaches: ${summary.breached}, Urgent: ${summary.urgent}`);
  console.log(`Compliance: ${report.complianceStatus}`);
  for (const v of vulns.filter(v => v.breached)) { await createGitHubIssue(v); }
  if (report.complianceStatus === 'NON_COMPLIANT') process.exit(1);
}

main().catch(e => { console.error(e); process.exit(1); });
