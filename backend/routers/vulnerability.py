"""
Infinity OS â€” Vulnerability Scanner Router
CVE scanning, SLA enforcement, remediation tracking
"""

from fastapi import APIRouter, Depends, Query, HTTPException, BackgroundTasks
from pydantic import BaseModel, Field
from typing import Optional, List, Dict, Any
from datetime import datetime, timezone
import asyncio

from auth import get_current_user, require_min_role, require_permission, UserRole
from vulnerability_scanner import (
    scan_dependencies, get_remediation_priority,
    Ecosystem, VulnerabilitySeverity, RemediationStatus,
    ScanResult, SLA_DAYS,
)

router = APIRouter(prefix="/api/v1/vulnerabilities", tags=["Vulnerability Scanner"])

# In-memory scan history (in production, persist to DB)
_scan_history: List[ScanResult] = []


class ScanRequest(BaseModel):
    manifest_content: str = Field(..., description="Content of requirements.txt or package.json")
    ecosystem: str = Field(..., description="PyPI or npm")
    max_packages: int = Field(50, ge=1, le=100)


class RemediationUpdateRequest(BaseModel):
    vuln_id: str
    status: str
    notes: Optional[str] = None


@router.post("/scan")
async def scan_manifest(
    request: ScanRequest,
    background_tasks: BackgroundTasks,
    current_user=Depends(require_min_role(UserRole.USER)),
):
    """Scan a dependency manifest for vulnerabilities."""
    valid_ecosystems = [e.value for e in Ecosystem]
    if request.ecosystem not in valid_ecosystems:
        raise HTTPException(400, f"Unsupported ecosystem. Valid: {valid_ecosystems}")

    result = await scan_dependencies(
        manifest_content=request.manifest_content,
        ecosystem=request.ecosystem,
        max_packages=request.max_packages,
    )

    # Store in history
    _scan_history.append(result)
    if len(_scan_history) > 100:
        _scan_history.pop(0)

    return result.to_dict()


@router.get("/scans")
async def list_scans(
    limit: int = Query(20, ge=1, le=100),
    current_user=Depends(require_min_role(UserRole.USER)),
):
    """List recent vulnerability scans."""
    recent = _scan_history[-limit:]
    return {
        "scans": [
            {
                "id": s.id,
                "scanned_at": s.scanned_at,
                "ecosystem": s.ecosystem,
                "package_count": s.package_count,
                "vulnerability_count": s.vulnerability_count,
                "critical_count": s.critical_count,
                "high_count": s.high_count,
                "sla_breached_count": s.sla_breached_count,
            }
            for s in reversed(recent)
        ],
        "total": len(_scan_history),
    }


@router.get("/scans/{scan_id}")
async def get_scan(
    scan_id: str,
    current_user=Depends(require_min_role(UserRole.USER)),
):
    """Get a specific scan result."""
    for scan in _scan_history:
        if scan.id == scan_id:
            return scan.to_dict()
    raise HTTPException(404, f"Scan {scan_id} not found")


@router.get("/scans/{scan_id}/remediation")
async def get_remediation_plan(
    scan_id: str,
    current_user=Depends(require_min_role(UserRole.USER)),
):
    """Get prioritized remediation plan for a scan."""
    for scan in _scan_history:
        if scan.id == scan_id:
            priority = get_remediation_priority(scan.vulnerabilities)
            return {
                "scan_id": scan_id,
                "total_items": len(priority),
                "sla_breached": sum(1 for p in priority if p["sla_breached"]),
                "remediation_plan": priority,
            }
    raise HTTPException(404, f"Scan {scan_id} not found")


@router.get("/sla-policy")
async def get_sla_policy():
    """Get the SLA policy for vulnerability remediation."""
    return {
        "policy": {
            severity.value: {
                "days": days,
                "description": f"{severity.value.upper()} vulnerabilities must be remediated within {days} days",
            }
            for severity, days in SLA_DAYS.items()
        },
        "reference": "ISO 27001 A.12.6.1, NIST CSF RS.MI-3",
    }


@router.get("/ecosystems")
async def list_ecosystems():
    """List supported package ecosystems."""
    return {"ecosystems": [e.value for e in Ecosystem]}


@router.get("/summary")
async def get_vulnerability_summary(
    current_user=Depends(require_min_role(UserRole.USER)),
):
    """Get overall vulnerability posture summary."""
    if not _scan_history:
        return {
            "message": "No scans performed yet",
            "total_scans": 0,
            "latest_scan": None,
        }

    latest = _scan_history[-1]
    total_critical = sum(s.critical_count for s in _scan_history)
    total_high = sum(s.high_count for s in _scan_history)
    total_sla_breached = sum(s.sla_breached_count for s in _scan_history)

    return {
        "total_scans": len(_scan_history),
        "latest_scan": {
            "id": latest.id,
            "scanned_at": latest.scanned_at,
            "ecosystem": latest.ecosystem,
            "vulnerability_count": latest.vulnerability_count,
            "critical_count": latest.critical_count,
            "high_count": latest.high_count,
            "sla_breached_count": latest.sla_breached_count,
        },
        "aggregate": {
            "total_critical_across_scans": total_critical,
            "total_high_across_scans": total_high,
            "total_sla_breached": total_sla_breached,
        },
        "risk_level": (
            "critical" if latest.critical_count > 0
            else "high" if latest.high_count > 0
            else "medium" if latest.medium_count > 0
            else "low"
        ),
    }